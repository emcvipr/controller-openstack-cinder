#!/usr/bin/python

# Copyright (c) 2012 EMC Corporation
# All Rights Reserved
#
# This software contains the intellectual property of EMC Corporation
# or is licensed to EMC Corporation from third parties.  Use of this
# software and the intellectual property contained therein is expressly
# limited to the terms and conditions of the License Agreement under which
# it is provided by or on behalf of EMC.

import os
import sys
import requests
import cookielib
import common
import getpass
from common import SOSError
from requests.exceptions import SSLError
from requests.exceptions import ConnectionError
from requests.exceptions import TooManyRedirects
from requests.exceptions import Timeout
import socket
import json
import ConfigParser


class Authentication(object):
    '''
    The class definition for authenticating the specified user 
    '''

    #Commonly used URIs for the 'Authentication' module
    URI_SERVICES_BASE               = ''
    URI_AUTHENTICATION = '/login'
    URI_VDC_AUTHN_PROFILE = URI_SERVICES_BASE + '/vdc/admin/authnproviders'
    URI_VDC_AUTHN_PROFILES = URI_SERVICES_BASE + '/vdc/admin/authnproviders/{0}'
    URI_VDC_ROLES =  URI_SERVICES_BASE + '/vdc/role-assignments'
    
    URI_LOGOUT                      = URI_SERVICES_BASE + '/logout'

    HEADERS = {'Content-Type': 'application/json', 'ACCEPT': 'application/json', 'X-EMC-REST-CLIENT': 'TRUE'}
    SEARCH_SCOPE=['ONELEVEL','SUBTREE']
    BOOL_VALS=['true','false']
    ZONE_ROLES=['SYSTEM_ADMIN', 'SECURITY_ADMIN', 'SYSTEM_MONITOR', 'SYSTEM_AUDITOR' ]

    def __init__(self, ipAddr, port):
        '''
        Constructor: takes IP address and port of the ViPR instance. 
        These are needed to make http requests for REST API   
        '''
        self.__ipAddr = ipAddr
        self.__port = port
        
    
    def authenticate_user(self, username, password, cookiedir, cookiefile):
        '''
        Makes REST API call to generate the cookiefile for the 
        specified user after validation.
        Returns:
            SUCCESS OR FAILURE
        '''
        SEC_REDIRECT                = 302 
        SEC_AUTHTOKEN_HEADER        = 'X-SDS-AUTH-TOKEN' 
        LB_API_PORT                 = 4443    # Port on which load-balancer/reverse-proxy listens to all incoming requests for ViPR REST APIs
        APISVC_PORT                 = 8443    # Port on which apisvc listens to incoming requests
        
        cookiejar=cookielib.LWPCookieJar()

        url = 'https://'+str(self.__ipAddr)+':'+str(self.__port)+self.URI_AUTHENTICATION

        try:
            if(self.__port == APISVC_PORT):
                login_response = requests.get(url, headers=self.HEADERS, verify=False,
                                          auth=(username,password), cookies=cookiejar, allow_redirects=False, timeout=common.TIMEOUT_SEC)
                if(login_response.status_code == SEC_REDIRECT):
                    location = login_response.headers['Location'] 
                    if(not location): 
                       raise SOSError(SOSError.HTTP_ERR, "The redirect location of the authentication service is not provided") 
                    # Make the second request 
                    login_response = requests.get(location, headers=self.HEADERS, verify=False, cookies=cookiejar, 
                                                        allow_redirects=False, timeout=common.TIMEOUT_SEC) 
                    if(not login_response.status_code == requests.codes['unauthorized']): 
                        raise SOSError(SOSError.HTTP_ERR, "The authentication service failed to reply with 401")
     
                    # Now provide the credentials 
                    login_response = requests.get(location, headers=self.HEADERS, auth=(username,password), verify=False, 
                                               cookies=cookiejar, allow_redirects=False, timeout=common.TIMEOUT_SEC) 
                    if(not login_response.status_code == SEC_REDIRECT): 
                        raise SOSError(SOSError.HTTP_ERR, "Access forbidden: Authentication required") 
                    location = login_response.headers['Location'] 
                    if(not location): 
                        raise SOSError(SOSError.HTTP_ERR, "The authentication service failed to provide the location of the service URI when redirecting back") 
                    authToken = login_response.headers[SEC_AUTHTOKEN_HEADER] 
                    if (not authToken): 
                        raise SOSError(SOSError.HTTP_ERR, "The token is not generated by authentication service") 
                    # Make the final call to get the page with the token 
                    newHeaders = self.HEADERS 
                    newHeaders[SEC_AUTHTOKEN_HEADER] = authToken 
                    login_response = requests.get(location, headers=newHeaders, verify=False, cookies=cookiejar, 
                                              allow_redirects=False, timeout=common.TIMEOUT_SEC) 
                    if(login_response.status_code != requests.codes['ok']): 
                        raise SOSError(SOSError.HTTP_ERR, "Login failure code: " + str(login_response.status_code) + " Error: " + login_response.text)
            elif(self.__port == LB_API_PORT):
                login_response = requests.get(url, headers=self.HEADERS, verify=False, cookies=cookiejar, allow_redirects=False)
                if(login_response.status_code == requests.codes['unauthorized']):
                    # Now provide the credentials
                    login_response = requests.get(url, headers=self.HEADERS, auth=(username,password), verify=False, cookies=cookiejar, allow_redirects=False)
                authToken = login_response.headers[SEC_AUTHTOKEN_HEADER] 
            else:
                raise SOSError(SOSError.HTTP_ERR, "Incorrect port number.  Load balanced port is: " +
                    str(LB_API_PORT) +
                    ", api service port is: " +
                    str(APISVC_PORT) +
                    ".")

            if (not authToken):
                raise SOSError(SOSError.HTTP_ERR, "The token is not generated by authentication service")    

            if (login_response.status_code != requests.codes['ok']):
                error_msg=None
                if(login_response.status_code == 401):
                    error_msg = "Access forbidden: Authentication required"
                elif(login_response.status_code == 403):
                    error_msg = "Access forbidden: You don't have sufficient privileges to perform this operation"
                elif(login_response.status_code == 500):
                    error_msg="Bourne internal server error"
                elif(login_response.status_code == 404):
                    error_msg="Requested resource is currently unavailable"
                elif(login_response.status_code == 405):
                    error_msg = "GET method is not supported by resource: " + url
                elif(login_response.status_code == 503):
                    error_msg = "Service temporarily unavailable: The server is temporarily unable to service your request"
                else:
                    error_msg=login_response.text
                    if isinstance(error_msg, unicode):
                        error_msg = error_msg.encode('utf-8')
                raise SOSError(SOSError.HTTP_ERR, "HTTP code: " +
                    str(login_response.status_code) +
                    ", response: " + str(login_response.reason) +
                    " [" + str(error_msg) + "]")
        
        except (SSLError, socket.error, ConnectionError, Timeout) as e:
            raise SOSError(SOSError.HTTP_ERR, str(e))

        
        form_cookiefile= None
        parentshellpid = None
        installdir_cookie = None
        if sys.platform.startswith('linux'):
            parentshellpid = os.getpid()
            if(cookiefile is None):
                if (parentshellpid is not None):
                    cookiefile=str(username)+'cookie'+str(parentshellpid)
                else:
                    cookiefile=str(username)+'cookie'
            form_cookiefile = cookiedir+'/'+cookiefile
            if (parentshellpid is not None):
                installdir_cookie = '/cookie/'+str(parentshellpid)
            else:
                installdir_cookie = '/cookie/cookiefile' 
        elif sys.platform.startswith('win'):
            if (cookiefile is None):
                cookiefile=str(username)+'cookie'
            form_cookiefile = cookiedir+'\\'+cookiefile
            installdir_cookie = '\\cookie\\cookiefile'
        else:
            if (cookiefile is None):
                cookiefile=str(username)+'cookie'
            form_cookiefile = cookiedir+'/'+cookiefile
            installdir_cookie = '/cookie/cookiefile'
	try:
            if(common.create_file(form_cookiefile)):
                tokenFile = open(form_cookiefile , "w") 
                if(tokenFile):
                    tokenFile.write(authToken) 
                    tokenFile.close()
                else:
                    raise SOSError(SOSError.NOT_FOUND_ERR,
                            " Failed to save the cookie file path "
                            + form_cookiefile) 

	except (OSError) as e:
               raise SOSError(e.errno, cookiedir +" "+e.strerror)
	except IOError as e:
		raise SOSError(e.errno , e.strerror)



        if (common.create_file(form_cookiefile)):
            #cookiejar.save(form_cookiefile, ignore_discard=True, ignore_expires=True);
            sos_cli_install_dir= common.getenv('VIPR_CLI_INSTALL_DIR')
            if (sos_cli_install_dir):
                if (not os.path.isdir(sos_cli_install_dir)):  
                    raise SOSError(SOSError.NOT_FOUND_ERR,
                     sos_cli_install_dir+" : Not a directory")    
                config_file = sos_cli_install_dir+installdir_cookie
                if (common.create_file(config_file)):
                    fd = open(config_file,'w+')
                    if (fd):
                        fd_content=os.path.abspath(form_cookiefile)+'\n'
                        fd.write(fd_content)
                        fd.close()
                        ret_val=username+' : Authenticated Successfully\n'+ \
                        form_cookiefile+' : Cookie saved successfully'
                    else:
                        raise SOSError(SOSError.NOT_FOUND_ERR,
                            config_file+" : Failed to save the cookie file path " 
                            + form_cookiefile)
                else:
                    raise SOSError(SOSError.NOT_FOUND_ERR,
                        config_file+" : Failed to create file")
            
            else:
                raise SOSError(SOSError.NOT_FOUND_ERR,
                    "VIPR_CLI_INSTALL_DIR is not set. Please check viprcli.profile")
        return ret_val


    def logout_user(self):
        '''
        Makes REST API call to generate the cookiefile for the 
        specified user after validation.
        Returns:
            SUCCESS OR FAILURE
        '''
        SEC_REDIRECT                = 302 
        SEC_AUTHTOKEN_HEADER        = 'X-SDS-AUTH-TOKEN' 
        

        try:
	    (s, h) = common.service_json_request(self.__ipAddr, self.__port, "GET",
                                             Authentication.URI_LOGOUT,
                                             None)
	    return s

    	except SOSError as e:
	    raise e


    def add_authentication_provider(self, mode , url, certificate, managerdn, managerpwd, searchbase, searchfilter, searchkey, groupattr, 
				    name, domains, whitelist, searchscope, description, disable, validatecertificate, maxpagesize):
        '''
	Makes REST API call to add authentication provider
        specified user after validation.
        Returns:
            SUCCESS OR FAILURE
	'''
	whitelist_array=[]
        whitelist_array = whitelist.split(',')

	domainlist_array=[]
	domainlist_array = domains.split(',')

	urlslist_array=[]
	urlslist_array = url.split(',')

        parms = { 'mode' : mode,
                 'server_urls' : urlslist_array,
                 'server_cert' : certificate,
                 'manager_dn' : managerdn,
                 'manager_password' : managerpwd,
                 'search_base' :searchbase,
                 'search_filter' : searchfilter,
                 'search_attribute_key' : searchkey,
		 'search_scope' : searchscope,
                 'group_attribute' : groupattr,
                 'name' : name,
                 'description' : description,
                 'disable' : disable,
		 'max_page_size' : maxpagesize,
		 'validate_certificates' : validatecertificate,
		 'domains' : domainlist_array,
                 'group_whitelist_values' : whitelist_array}


        body = json.dumps(parms)

	(s, h) = common.service_json_request(self.__ipAddr, self.__port, "POST",
                                             Authentication.URI_VDC_AUTHN_PROFILE,
                                             body)
	


    def list_authentication_provider(self):
        '''
        Makes REST API call to list authentication providers
        Returns:
            SUCCESS OR FAILURE
	'''
	(s, h) = common.service_json_request(self.__ipAddr, self.__port, "GET",
                                             Authentication.URI_VDC_AUTHN_PROFILE,
                                             None)

	o = common.json_decode(s)

	profiles = []

	for pr in o['authnprovider']:
	    profiles.append(pr)

	return profiles

	
    def query_authentication_provider(self, name):
        '''
	Makes REST API call to query authentication providers
        Returns:
            SUCCESS OR FAILURE
	'''
	profiles = self.list_authentication_provider()

	for pr in profiles:
	
	    profile = self.show_authentication_provider_by_uri(pr['id'])
	    if (profile['name'] == name):
                return profile['id']



    def show_authentication_provider(self, name, xml=False):
        '''
	Makes REST API call to show authentication providers
        Returns:
            SUCCESS OR FAILURE
	'''
	profiles = self.list_authentication_provider()

	for pr in profiles:
	    profile = self.show_authentication_provider_by_uri(pr['id'], False)

	    if ( (profile) and (profile['name'] == name) ):
		#if(xml):
	         #   profile = self.show_authentication_provider_by_uri(pr['id'], xml)
                  #  return  common.format_xml(profile)
		return profile
	
	raise SOSError(SOSError.NOT_FOUND_ERR, "Authentication Provider with name '" +name+ "' not found")
		

    def delete_authentication_provider(self, name):
        '''
        Makes REST API call to delete authentication provider
        Returns:
            SUCCESS OR FAILURE
        '''
	uri = self.query_authentication_provider(name)

        (s, h) = common.service_json_request(self.__ipAddr, self.__port, "DELETE",
                        Authentication.URI_VDC_AUTHN_PROFILES.format(uri), None)

        return str(s) + " ++ " + str(h)







    def show_authentication_provider_by_uri(self, uri, xml=False):
        '''
	Makes REST API call to show  authentication provider by uri
        Returns:
            SUCCESS OR FAILURE
	'''

	(s, h) = common.service_json_request(self.__ipAddr, self.__port, "GET",
                                             Authentication.URI_VDC_AUTHN_PROFILES.format(uri),
                                             None)

	if(xml==False):
            o = common.json_decode(s)
            if('inactive' in o):
                if(o['inactive'] == True):
                    return None
	    return o
	else:
	    return s



    def update_authentication_provider(self, mode , add_urls, remove_urls, certificate, 
					managerdn, managerpwd, searchbase, searchfilter, 
					searchkey, groupattr, name, add_domains, 
					remove_domains, add_whitelist, remove_whitelist, 
					searchscope, description, disable, 
					validatecertificate, maxpagesize):
        '''
        Makes REST API call to generate the cookiefile for the 
        specified user after validation.
        Returns:
            SUCCESS OR FAILURE
	'''

	authnprov_id  = self.query_authentication_provider(name)

        server_assignments = dict()
        domain_assignments = dict()
        whitelist_assignments = dict()

        urls = dict();
        domains = dict();
        whitelist = dict();

	urls['add'] = []
        for iter in add_urls:
	    if(iter is not ""):
                urls['add'].append(iter)

	urls['remove'] = []
        for iter in remove_urls:
	    if(iter is not ""):
                urls['remove'].append(iter)

	domains['add'] = []
        for iter in add_domains:
	    if(iter is not ""):
                domains['add'].append(iter)

	domains['remove'] = []
        for iter in remove_domains:
	    if(iter is not ""):
                domains['remove'].append(iter)

	whitelist['remove'] = []
        for iter in remove_whitelist:
	    if(iter is not ""):
                whitelist['remove'].append(iter)

	whitelist['add'] = []
        for iter in add_whitelist:
	    if(iter is not ""):
                whitelist['add'].append(iter)

        '''for domain in add_domains:
                domainlist.append({'domain': domain})
            domains['add'] = domainlist #add_domains'''


        parms = { 'mode' : mode,
                 'manager_dn' : managerdn,
                 'manager_password' : managerpwd,
                 'search_base' :searchbase,
                 'search_filter' : searchfilter,
                 'search_attribute_key' : searchkey,
                 'search_scope' : searchscope,
                 'group_attribute' : groupattr,
                 'name' : name,
                 'description' : description,
                 'disable' : disable,
                 'max_page_size' : maxpagesize,
                 'validate_certificates' : validatecertificate}


	if( (len(urls['add']) > 0) or (len(urls['remove'])>0) ):
	    parms['server_url_changes'] = urls

	if( (len(domains['remove']) > 0) or (len(domains['add'])>0) ):
	    parms['domain_changes'] = domains

	if( (len(whitelist['add']) > 0) or (len(whitelist['remove'])>0) ):
	    parms['group_whitelist_value_changes'] = whitelist

        body = json.dumps(parms)
	
        (s, h) = common.service_json_request(self.__ipAddr, self.__port, "PUT",
                                             Authentication.URI_VDC_AUTHN_PROFILES.format(authnprov_id),
                                             body)



    def add_vdc_role(self, role, subject_id, group):
        '''
        Makes a REST API call to add vdc role
         '''

        if(subject_id):
            objecttype = 'subject_id'
            objectname = subject_id
        else:
            objecttype = 'group'
            objectname = group

        parms = {
                 "add" : [ { "role" : [role], objecttype : objectname }]
                 }

        body = json.dumps(parms)

        (s, h) = common.service_json_request(self.__ipAddr, self.__port, "PUT",
                                             Authentication.URI_VDC_ROLES,
                                             body)



    def list_vdc_role(self):
        '''
        Makes a REST API call to add vdc role
         '''

        (s, h) = common.service_json_request(self.__ipAddr, self.__port, "GET",
                                             Authentication.URI_VDC_ROLES,
                                             None)

        o = common.json_decode(s)

	return o


    def delete_vdc_role(self, role, subject_id, group):
        '''
        Makes a REST API call to add vdc role
         '''

        if(subject_id):
            objecttype = 'subject_id'
            objectname = subject_id
        else:
            objecttype = 'group'
            objectname = group

        parms = {
                 "remove" : [ { "role" : [role], objecttype : objectname }]
                 }

        body = json.dumps(parms)

        (s, h) = common.service_json_request(self.__ipAddr, self.__port, "PUT",
                                             Authentication.URI_VDC_ROLES,
                                             body)








def add_authentication_provider(args):
    obj = Authentication(args.ip, args.port)
    try:
	# read authentication provider  parameters from configuration file
        config = ConfigParser.RawConfigParser()
        inif = open(args.configfile, 'rb')
        config.readfp(inif)
	sectionslst = config.sections()
	
	if(len(sectionslst) == 0):
	    raise SOSError(SOSError.NOT_FOUND_ERR,
                            "Authentication Provider configuration file is empty")

	for sectioniter in sectionslst:
	    mode = config.get(sectioniter, "mode")
            url = config.get(sectioniter, "url")
            managerdn = config.get(sectioniter, 'managerdn')
            searchbase = config.get(sectioniter, 'searchbase')
            searchfilter = config.get(sectioniter, 'searchfilter')
            searchkey = config.get(sectioniter, 'searchkey')
            groupattr = config.get(sectioniter, 'groupattr')
            name = config.get(sectioniter, 'name')
            domains = config.get(sectioniter, 'domains')
            whitelist = config.get(sectioniter, 'whitelist')
            description = config.get(sectioniter, 'description')
	    searchscope = config.get(sectioniter, 'searchscope')

	    validatecertificate =  config.get(sectioniter, 'validatecertificate')
	    maxpagesize = config.get(sectioniter, 'maxpagesize')
            disable = config.get(sectioniter, 'disable')
	
	    if(domains is "") or (whitelist is "") or (url is "") or (managerdn is "") or \
	      (searchbase is "") or (searchfilter is "")  or \
	      (searchkey is "") or (groupattr is "") or (name is "") or (description is "") or (searchscope is "") or (mode is ""):
     		raise SOSError(SOSError.VALUE_ERR, "domains,"+ 
			"whitelist,url,managerdn,"+ 
			"searchbase,searchfilter,searchkey,groupattr," +
			"name,description,searchscope and mode can not be empty")

            defined_and_valid_value('search scope', searchscope , Authentication.SEARCH_SCOPE)
            defined_and_valid_value('disable', disable , Authentication.BOOL_VALS)
            defined_and_valid_value('validatecertificate', validatecertificate , Authentication.BOOL_VALS)

	    passwd_user = common.get_password(name)

            res = obj.add_authentication_provider(mode, url, None, managerdn, passwd_user, 
					     searchbase, searchfilter, searchkey,
					     groupattr,  name, domains, whitelist, searchscope, description, disable, validatecertificate, maxpagesize)


    except IOError as e:
	common.format_err_msg_and_raise("add", "authentication provider", e[1], e.errno)

    except SOSError as e:
	common.format_err_msg_and_raise("add", "authentication provider", e.err_text, e.err_code)

    except ConfigParser.NoOptionError as e:
	common.format_err_msg_and_raise("add", "authentication provider", str(e) , SOSError.NOT_FOUND_ERR)

    except (ConfigParser.ParsingError, ConfigParser.Error) as  e:
	common.format_err_msg_and_raise("add", "authentication provider", str(e) , SOSError.VALUE_ERR)

        

def delete_authentication_provider(args):
    obj = Authentication(args.ip, args.port)
    try:
        res = obj.delete_authentication_provider(args.name)
    except SOSError as e:
        common.format_err_msg_and_raise("delete", "Authentication Provider", e.err_text, e.err_code)




def show_authentication_provider(args):
    obj = Authentication(args.ip, args.port)
    try:
        res = obj.show_authentication_provider(args.name, args.xml)
	return common.format_json_object(res)
    except SOSError as e:
        common.format_err_msg_and_raise("show", "Authentication Provider", e.err_text, e.err_code)


def update_authentication_provider(args):
    obj = Authentication(args.ip, args.port)
    try:
	# read authentication provider  parameters from configuration file
        config = ConfigParser.RawConfigParser()
        inif = open(args.configfile, 'rb')
        config.readfp(inif)
	sectionslst = config.sections()
	
	if(len(sectionslst) == 0):
	    raise SOSError(SOSError.NOT_FOUND_ERR,
                            "Authentication Provider configuration file is empty")

	for sectioniter in sectionslst:
	    mode = config.get(sectioniter, "mode")

            add_urls = config.get(sectioniter, "add-urls")
            remove_urls = config.get(sectioniter, "remove-urls")
            add_domains = config.get(sectioniter, 'add-domains')
            remove_domains = config.get(sectioniter, 'remove-domains')
            add_whitelist = config.get(sectioniter, 'add-whitelist')
            remove_whitelist = config.get(sectioniter, 'remove-whitelist')

            managerdn = config.get(sectioniter, 'managerdn')
            searchbase = config.get(sectioniter, 'searchbase')
            searchfilter = config.get(sectioniter, 'searchfilter')
            searchkey = config.get(sectioniter, 'searchkey')
            groupattr = config.get(sectioniter, 'groupattr')
            name = config.get(sectioniter, 'name')
            description = config.get(sectioniter, 'description')
	    searchscope = config.get(sectioniter, 'searchscope')

	    
	    validatecertificate =  config.get(sectioniter, 'validatecertificate')
	    maxpagesize = config.get(sectioniter, 'maxpagesize')
            disable = config.get(sectioniter, 'disable')
	

	    defined_and_valid_value('search scope', searchscope , Authentication.SEARCH_SCOPE)
	    defined_and_valid_value('disable', disable , Authentication.BOOL_VALS)
	    defined_and_valid_value('validatecertificate', validatecertificate , Authentication.BOOL_VALS)

	    passwd_user = common.get_password(name)

            res = obj.update_authentication_provider(mode, add_urls.split(','), remove_urls.split(','), 
					     None, managerdn, passwd_user, 
					     searchbase, searchfilter, searchkey,
					     groupattr, name, add_domains.split(','), remove_domains.split(','), 
					     add_whitelist.split(','), remove_whitelist.split(','), searchscope, 
					     description, disable, validatecertificate, maxpagesize)


    except IOError as e:
	common.format_err_msg_and_raise("update", "authentication provider", e[1], e.errno)

    except SOSError as e:
	common.format_err_msg_and_raise("update", "authentication provider", e.err_text, e.err_code)

    except ConfigParser.NoOptionError as e:
        common.format_err_msg_and_raise("update", "authentication provider", str(e) , SOSError.NOT_FOUND_ERR)

    except (ConfigParser.ParsingError, ConfigParser.Error) as e:
        common.format_err_msg_and_raise("update", "authentication provider", str(e) , SOSError.VALUE_ERR)
  



def defined_and_valid_value(fieldname, value, valid_list):
    if( (value) and (value not in valid_list) ):
                raise SOSError(SOSError.VALUE_ERR,
                       fieldname+ "can take values from among"+  str(valid_list) )
	

def list_authentication_provider(args):
    obj = Authentication(args.ip, args.port)
    try:
        uris = obj.list_authentication_provider()

        output = []

        for uri in uris:
            if(obj.show_authentication_provider_by_uri(uri['id'])):
                output.append(obj.show_authentication_provider_by_uri(uri['id']))
        if(len(output) > 0):
            if(args.verbose == True):
                return common.format_json_object(output)
            elif(args.long == True):
                from common import TableGenerator
                TableGenerator(output, [ 'module/name', 'server_urls', 'mode', 'domains','group_attribute']).printTable()
            else:
                from common import TableGenerator
                TableGenerator(output, [ 'module/name','server_urls','mode']).printTable()
    except SOSError as e:
            if(e.err_code == SOSError.NOT_FOUND_ERR):
                raise SOSError(SOSError.NOT_FOUND_ERR,
                      "Tenant list failed: " + e.err_text)
            else:
                raise e




def authenticate_user(args):
    obj = Authentication(args.ip, args.port)
    try:
        if (args.username):
            if sys.stdin.isatty():
                passwd_user = getpass.getpass(prompt="Password : ")
            else:
                passwd_user = sys.stdin.readline().rstrip()
        else:
            raise SOSError(SOSError.CMD_LINE_ERR, args.username+" : invalid username")
        res = obj.authenticate_user(args.username, passwd_user, args.cookiedir,
                args.cookiefile)
        return res
    except SOSError as e:
        raise e
        
def authenticate_parser(parent_subparser, sos_ip, sos_port):
    # main authentication parser

    authenticate_parser = parent_subparser.add_parser('authenticate',
                                description='ViPR authentication CLI usage',
                                conflict_handler='resolve',
                                help='Authenticate ViPR user')
    authenticate_parser.add_argument('-cf', '-cookiefile',
                metavar='<cookiefile>',
                                help='filename for storing cookie information',
                dest='cookiefile')
    authenticate_parser.add_argument('-hostname', '-hn',
                metavar='<hostname>',
                default=sos_ip,
                dest='ip',
                help='Hostname (fully qualifiled domain name) of ViPR')
    authenticate_parser.add_argument('-port', '-po',
                type=int,
                metavar='<port_number>',
                default=sos_port,
                dest='port',
                help='port number of ViPR')

    mandatory_args = authenticate_parser.add_argument_group('mandatory arguments')
    mandatory_args.add_argument('-u','-username',
                metavar='<username>',
                help='username for login',
                dest='username',
                required=True)
    mandatory_args.add_argument('-d', '-cookiedir',
                metavar='<cookiedir>',
                help='cookie directory to store cookie files',
                dest='cookiedir',
                required=True)
    authenticate_parser.set_defaults(func=authenticate_user)
    

def logout_user(args):
    obj = Authentication(args.ip, args.port)
    try:
        res = obj.logout_user()
    except SOSError as e:
        raise e

def logout_parser(parent_subparser, sos_ip, sos_port):
    # main authentication parser

    logout_parser = parent_subparser.add_parser('logout',
                                description='ViPR authentication CLI usage',
                                conflict_handler='resolve',
                                help='Logout ViPR user')
    logout_parser.add_argument('-cf', '-cookiefile',
                metavar='<cookiefile>',
                                help='filename for storing cookie information',
                dest='cookiefile')
    logout_parser.add_argument('-hostname', '-hn',
                metavar='<hostname>',
                default=sos_ip,
                dest='ip',
                help='Hostname (fully qualifiled domain name) of ViPR')
    logout_parser.add_argument('-port', '-po',
                type=int,
                metavar='<port_number>',
                default=sos_port,
                dest='port',
                help='port number of ViPR')


    logout_parser.set_defaults(func=logout_user)


def add_auth_provider_parser(subcommand_parsers , common_parser):
    # add command parser
    add_auth_provider_parser = subcommand_parsers.add_parser('add-provider',
                                description='ViPR Authentication Provider Add CLI usage.',
				parents=[common_parser],
                                conflict_handler='resolve',
                                help='Add a Authentication Provider')

    mandatory_args = add_auth_provider_parser.add_argument_group('mandatory arguments')

    mandatory_args.add_argument('-configfile',
                		 metavar='<configfile>',
                                help='config file for authentication provider',
                		dest='configfile',
				required=True)


    add_auth_provider_parser.set_defaults(func=add_authentication_provider)



def show_auth_provider_parser(subcommand_parsers, common_parser):
    # show command parser
    show_auth_provider_parser = subcommand_parsers.add_parser('show-provider',
                                description='ViPR Authentication Provider Show CLI usage.',
                                parents=[common_parser],
                                conflict_handler='resolve',
                                help='Show an Authentication Provider')

    mandatory_args = show_auth_provider_parser.add_argument_group('mandatory arguments')



    mandatory_args.add_argument('-name',
                		metavar='<name>',
                                help='name of the authentication provider',
                		dest='name',
				required=True)


    show_auth_provider_parser.add_argument('-xml',
                            dest='xml',
                            action='store_true',
                            help='XML response')


    show_auth_provider_parser.set_defaults(func=show_authentication_provider)



def update_auth_provider_parser(subcommand_parsers, common_parser):
    # update command parser
    update_auth_provider_parser = subcommand_parsers.add_parser('update',
                                description='ViPR Authentication Provider Update CLI usage.',
                                parents=[common_parser],
                                conflict_handler='resolve',
                                help='Update a Authentication Provider')

    mandatory_args = update_auth_provider_parser.add_argument_group('mandatory arguments')


    mandatory_args.add_argument('-configfile',
                		 metavar='<configfile>',
                                help='config file for authentication provider',
                		dest='configfile',
				required=True)

    update_auth_provider_parser.set_defaults(func=update_authentication_provider)



def delete_auth_provider_parser(subcommand_parsers, common_parser):
    # delete command parser
    delete_auth_provider_parser = subcommand_parsers.add_parser('delete-provider',
                                description='ViPR Authentication Provider delete CLI usage.',
                                parents=[common_parser],
                                conflict_handler='resolve',
                                help='Delete an Authentication Provider')

    mandatory_args = delete_auth_provider_parser.add_argument_group('mandatory arguments')

    mandatory_args.add_argument('-name',
                                metavar='<name>',
                                help='name of the authentication provider',
                                dest='name',
                                required=True)

    delete_auth_provider_parser.set_defaults(func=delete_authentication_provider)





def list_auth_provider_parser(subcommand_parsers, common_parser):
    # update command parser
    list_auth_provider_parser = subcommand_parsers.add_parser('list-providers',
                                description='ViPR Authentication Provider List CLI usage.',
                                parents=[common_parser],
                                conflict_handler='resolve',
                                help='List Authentication Providers')


    list_auth_provider_parser.add_argument('-verbose', '-v',
                             action='store_true',
                             help='List Authentication providers with details',
                             dest='verbose')

    list_auth_provider_parser.add_argument('-long', '-l',
                             action='store_true',
                             help='List Authentication providers with more details in tabular format',
                             dest='long')


    list_auth_provider_parser.set_defaults(func=list_authentication_provider)



def add_vdc_role_parser(subcommand_parsers , common_parser):
    # add command parser
    add_vdc_role_parser = subcommand_parsers.add_parser('add-vdc-role',
                                description='ViPR Add vdc Role CLI usage.',
                                conflict_handler='resolve',
                                help='Add a vdc role to an user')

    mandatory_args = add_vdc_role_parser.add_argument_group('mandatory arguments')

    mandatory_args.add_argument('-role',
                                help='role to be added',
                                dest='role',
                                required=True,
				choices=Authentication.ZONE_ROLES)


    arggroup =  add_vdc_role_parser.add_mutually_exclusive_group(required=True)

    arggroup.add_argument('-subject-id', '-sb',
                                help='Subject ID',
                                dest='subjectid',
                                metavar='<subjectid>')

    arggroup.add_argument('-group', '-g',
                             help='Group',
                             dest='group',
                             metavar='<group>')

    add_vdc_role_parser.set_defaults(func=add_vdc_role)




def add_vdc_role(args):
    obj = Authentication(args.ip, args.port)

    try:
        res = obj.add_vdc_role(args.role, args.subjectid, args.group)
    except SOSError as e:
        raise e



def list_vdc_role_parser(subcommand_parsers , common_parser):
    # add command parser
    list_vdc_role_parser = subcommand_parsers.add_parser('list-vdc-role',
                                description='ViPR List vdc Roles CLI usage.',
                                parents=[common_parser],
                                conflict_handler='resolve',
                                help='List Vdc Roles')


    list_vdc_role_parser.set_defaults(func=list_vdc_role)




def list_vdc_role(args):
    obj = Authentication(args.ip, args.port)

    try:
        res = obj.list_vdc_role()
	return common.format_json_object(res)
    except SOSError as e:
        raise e






def delete_role_parser(subcommand_parsers, common_parser):
    # register command parser
    delete_role_parser = subcommand_parsers.add_parser('delete-role',
                                description='ViPR delete Vdc role CLI usage.',
                                parents=[common_parser],
                                conflict_handler='resolve',
                                help='Delete a vdc role of an user')



    mandatory_args = delete_role_parser.add_argument_group('mandatory arguments')


    mandatory_args.add_argument('-role',
                                 metavar='<role>',
                                help='role to be deleted',
                                dest='role',
                                required=True,
				choices=Authentication.ZONE_ROLES)


    arggroup =  delete_role_parser.add_mutually_exclusive_group(required=True)

    arggroup.add_argument('-subject-id', '-sb',
                                help='Subject ID',
                                dest='subjectid',
                                metavar='<subjectid>')

    arggroup.add_argument('-group', '-g',
                             help='Group',
                             dest='group',
                             metavar='<group>')


    delete_role_parser.set_defaults(func=delete_vdc_role)



def delete_vdc_role(args):
    obj = Authentication(args.ip, args.port)

    try:
        res = obj.delete_vdc_role( args.role, args.subjectid, args.group)
    except SOSError as e:
        raise e





def authentication_parser(parent_subparser, common_parser):
    # main authentication parser
    parser = parent_subparser.add_parser('authentication',
                description='ViPR Authentication Providers CLI usage',
                parents=[common_parser],
                conflict_handler='resolve',
                help='Operations on Authentication')
    
    subcommand_parsers = parser.add_subparsers(help='Use One Of Commands')

    # authentication provider parser
    add_auth_provider_parser(subcommand_parsers , common_parser)

    show_auth_provider_parser(subcommand_parsers , common_parser)

    update_auth_provider_parser(subcommand_parsers , common_parser)

    delete_auth_provider_parser(subcommand_parsers , common_parser)

    list_auth_provider_parser(subcommand_parsers , common_parser)

    add_vdc_role_parser(subcommand_parsers , common_parser)

    list_vdc_role_parser(subcommand_parsers , common_parser)

    delete_role_parser(subcommand_parsers , common_parser)
